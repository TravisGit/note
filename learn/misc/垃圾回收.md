

## 垃圾回收
讲解：https://www.zhihu.com/question/21539353/answer/18596488

一般方法：
* 引用计数（标记——整理GC）：局部信息，引用计数。缺点在于对循环引用难以处理。
* Trace GC（可达性算法）：从根节点扫描，得到的是全局的对象图信息。是主流方法，但延迟会大一些，在内存紧张的环境下（会频繁调用），可以考虑用引用计数

语言：
* Java\C#有垃圾回收，而C++11才引入垃圾回收（智能指针，基于引用计数）

C++11的智能指针与Java的垃圾回收：https://www.zhihu.com/question/30986949

1. 仍然需要普通指针，比如在实现一些数据结构时。因为缺少option/maybe这样的东西，使得有时普通指针仍然是最好的选择，unique_ptr不总是能方便地表达option.和第三方或遗留代码交互也有需求。但是，实践上，把普通指针尽可能从接口上消除是可行的，一定要竭力避免智能指针和普通指针的混用，因为这会导致所有权判断变得混乱，严重影响代码质量。
2. shared_ptr很好用，但普适性不如gc. 计数器不仅有空间开销，还有性能开销。计数器的频繁修改在多核情况下对cache是很不友好的，不能因为sp复制代价貌似很小就肆意复制。
3. sp只是对象所有权的管理方式之一，和gc的出发点完全不同，虽然两者在某些局部有很大的相似性。没有太多可比性

作者：孙朝阳
链接：https://www.zhihu.com/question/30986949/answer/52265032
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。




## java内存管理简介
http://blog.jobbole.com/37273/       
内存状态：
     * 可达状态
     * 可恢复状态
     * 不可达状态
回收算法：
     * 支持压缩的垃圾回收（标记并清除+压缩） 遍历一次
     * 不压缩的垃圾回收（标记-清除） 遍历二次
     * 复制式垃圾回收（复制可达对象）
内存分代：
     * Young
     * Old
     * permannent


JNI系列文章：http://blog.csdn.net/a345017062/article/category/1256568


## JNI之内存泄漏
强烈推荐：https://www.ibm.com/developerworks/cn/java/j-lo-jnileak/
JAVA中的内存泄漏，从泄漏的内存位置角度，可以分为：
1. JVM中Java Heap的内存泄漏；
2. JVM内存中native memory的内存泄漏。
 
Java Heap中out of memory异常的出现有两种原因：
1. 程序过于庞大，致使过多Java对象的同时存在；
2. 程序编写的错误导致JavaHeap内存泄漏
 
Java Heap以外的内存空间称为JVM的nativememory
 
Native memory的内存泄漏，其实都是C/C++代码编写错误导致的C端和Java端的泄露：

问题代码 | 描述 | 泄露位置
---------|----------|---------
 NativeCode | C/C++代码本身内存管理导致的泄露 | Native heap
 Global Reference | C/C++未及时释放无用的Global Reference导致Java端对象的引用一直被持有无法回收 | Java Heap
 Local Reference | C/C++申请过多Local Reference不及时释放，导致Java端对象的引用一直被持有无法回收 | Java Heap overflow
 Local Reference | C/C++申请过多Local Reference不及时释放，导致Native端的Local Refrence Table溢出 | Native Overflow

* Global Reference是需要在Native Code中手动释放的
* Local Reference在函数退出时会自动释放，但如果函数执行过程中申请了过多，会导致overflow问题，也属于内存泄露。


简而言之，对于native code中使用，而实际存储在java heap中的对象，如下例：
str =(*env)->NewStringUTF(env, "0");
str是native code中的局部变量，但其指向的string存储在java heap中，str指向了local ref table中的一个local ref，这个local ref又映射到java heap中的string对象。
如果str是全局变量，则其指向的是global ref table，这个table中的变量需要显示的调用 DeleteGlobalRef删除。

JNI中内存应用的种类，http://blog.csdn.net/a345017062/article/details/8068928   ：有举例，讲的很全面

1、 JNI支持三种引用：局部引用、全局引用、弱全局引用（下文简称“弱引用”）。

2、 局部引用和全局引用有不同的生命周期。当本地方法返回时，局部引用会被自动释放。而全局引用和弱引用必须手动释放。

3、 局部引用或者全局引用会阻止GC回收它们所引用的对象，而弱引用则不会。

4、 不是所有的引用可以被用在所有的场合。例如，一个本地方法创建一个局部引用并返回后，再对这个局部引用进行访问是非法的。（如保存局部引用到全局或静态变量中后续使用，是非法的）

5、局部引用在方法返回时才自动销毁，因此如果本地方法中包含过多的局部引用，用完后要及时销毁。

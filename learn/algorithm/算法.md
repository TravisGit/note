### 动态规划

例 4-9. 四种方法计算梵文旋律：（一）迭代；（二）自底向上的动态规划；（三）自上而
下的动态规划；（四）内置默记法。
```python
def virahanka1(n):
    if n == 0:
        return [""]
    elif n == 1:
        return ["S"]
    else:
        s = ["S" + prosody for prosody in virahanka1(n-1)]
        l = ["L" + prosody for prosody in virahanka1(n-2)]
    return s + l

def virahanka2(n):
    lookup = [[""], ["S"]]
    for i in range(n-1):
        s = ["S" + prosody for prosody in lookup[i+1]]
        l = ["L" + prosody for prosody in lookup[i]]
        lookup.append(s + l)
    return lookup[n]

def virahanka3(n, lookup={0:[""], 1:["S"]}):
    if n not in lookup:
        s = ["S" + prosody for prosody in virahanka3(n-1)]
        l = ["L" + prosody for prosody in virahanka3(n-2)]
        lookup[n] = s + l
    return lookup[n]


```


迭代：形式简洁，大量的无用计算
自底向上：空间换时间，保留中间结果，避免重复计算
自上而下：空间换时间，而且有些中间结果是不需要用到的，这里可以避免这种计算


## 解题思路

解决问题不能够灵光一现，要总结特定的套路一步一步的走下去，有章法的进行。穷举了所有的套路也无法解决，才算是无能为力。

1. 转化问题
    * 取反
    * 取极限，如n=1时
    * 类比，如将某个问题转化为曾经见过的问题

2. 解决问题
    * 问题可以用哪种数据结构描述，该数据结构可解决的问题
        * 链表：
        * 栈：
        * 位操作：
        * 树：
        * 图：

    * 非常见的数据结构可解的特定问题
        * 红黑树
        * 线段树
        * B+树

    * 动态规划
        * 一维问题：f(n)与f(n-1)的关系，如斐波那契
        * 二维问题：f(n,m)与f(i,j)的关系，其中i<n, j<m，如f(n,m) = max(f(n,m-1), f(n-1,m-1), f(n-1), f(m))
        * 主要在于建立递归关系，最终写法还是用递推式，可记录中间结果
    * 贪心算法
        * n=1时的处理方案
        * n=1时的方案做n次，是否就是n=n时的结果
        * 每一步是否有一个最优解法，局部最优是否可推得总体最优
        * 是一种递推的思维，与动归有些互补

3. 编程细节
    * 哑节点
    * 

**1和2是解题的思路，3是编程常用小技巧**

4. 基础知识掌握
    * 大规模数据处理的常见方法
        * 通过hash，将数据均n匀分成不相干的m份，每份去处理，最终合并

    * 常见数据结构的基本操作
        * 链表：合并、排序、插入
        * 栈：实现
        * 位操作：
        * 树：遍历、寻找祖先节点
        * 图：BFS、DFS、最短路径

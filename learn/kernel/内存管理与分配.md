

malloc(), vmalloc()和kmalloc()区别:

* kmalloc和vmalloc是分配的是内核的内存,malloc分配的是用户的内存

* kmalloc保证分配的内存在物理上是连续的,vmalloc保证的是在虚拟地址空间上的连续,malloc和vmalloc一样，也是虚连，物不一定连。

* kmalloc能分配的大小有限,vmalloc和malloc能分配的大小相对较大

* 内存只有在要被DMA访问的时候才需要物理上连续

* vmalloc比kmalloc要慢

其他函数：
* kzalloc() --- kmalloc + memset 0;
* kcalloc() --- 分配n块内存，kmalloc + memset 0



## cpu cache mmu memory
cpu访问内存的顺序
cpu——cache——mmu（tlb）——memory 
cpu的cache，是为了加速内存的访问，cache中存储了最近访问过的内存内容，当cache命中，则不需要访问内存，未命中才需要去内存取数据
mmu是内存管理单元（维护了虚拟地址到物理地址映射），tlb为mmu的一部分，是内存中的页表的cache，也是一种cache，对应于实际的硬件电路，是内存管理单元mmu用于改进虚拟地址到物理地址转换速度的缓存。如果没有tlb，每次数据访问都要两次访问内存，一次用于通过虚拟地址在页表查询物理地址，一次用于取数据。
http://blog.csdn.net/jeiwt/article/details/5911358

dma：不需要cpu参与的，可让外设与系统内存之间进行双向数据传输的机制。DMA将CPU从IO数据传输过程中解放出来。DMA结束后，DMAC（DMA控制器）通过中断通知CPU。

虚拟地址、物理地址、总线地址
CPU角度看到的是虚拟地址，需要通过mmu转换为物理地址
CPU-MMU控制器外围角度看到的是物理地址
设备角度看到的是总线地址
对于ISA与PCI而言，总线地址即物理地址，但并不是每个平台均如此。


buddy——slab——kmalloc

查看内存信息：cat /proc/meminfo
查看slab信息：cat /proc/slabinfo
查看buddy信息：cat /proc/buddyinfo
slabtop命令，查看slab各数据结构占用内存


slab
     层次：在buddy机制的上层，进行二次的内存管理
     问题：buddy是以页面来管理内存，一个页面通常为4k，如果是几百字节的内存频繁申请释放，则buddy的次数会很多。
     方式：将一个页面分为多个大小不一的slab，应用释放内存后，是还给了slab分配器，但slab分配器没有还给buddy。当下一次需要同样大小的slab时，slab分配器直接将合适的slab返回，而不需要再次去buddy中申请。避免了小内存频繁申请和释放页面的问题。
     类比：相当于一个内存池。

内存池
     优点：加速分配释放，减少内存碎片
     问题：slab本身就像一个内存池，应用层再实现自己的内存池有何意义？
     意义：1. 应用层根据自身的数据特点去实现内存池会更高效。

malloc 的glibc库实现，也是具有内存二次管理功能的。


虚拟地址、逻辑地址、线性地址：
简而言之：
* 逻辑地址：段式内存管理的地址，selector:offset形式
* 线性地址：逻辑（虚拟）地址经过分段转化为线性地址， 线性地址经过分页转为物理地址
* 虚拟地址：EIP寄存器的值，也就是offset，也就是程序中指针的值

或者理解为：http://blog.csdn.net/lux_veritas/article/details/8271158
* 逻辑地址与线性地址统称虚拟地址，虚拟地址通过MMU转化为物理地址
* CPU通过两层地址翻译的过程得到一条物理地址：逻辑地址->线性地址，线性地址->物理地址。

作者：Hao Lee
链接：https://www.zhihu.com/question/29918252/answer/163114415
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

在 Intel 平台下，逻辑地址(logical address)是 selector:offset 这种形式，selector 是 CS 寄存器的值，offset 是 EIP 寄存器的值。如果用 selector 去 GDT( 全局描述符表 ) 里拿到 segment base address(段基址) 然后加上 offset(段内偏移)，这就得到了 linear address。我们把这个过程称作段式内存管理。
如果再把 linear address 切成四段，用前三段分别作为索引去PGD、PMD、Page Table里查表，最终就会得到一个页表项(Page Table Entry)，那里面的值就是一页物理内存的起始地址，把它加上 linear address 切分之后第四段的内容(又叫页内偏移)就得到了最终的 physical address。我们把这个过程称作页式内存管理。

问题来了，为什么没提到 virtual address，这是个什么东西？其实在 Intel IA-32 手册里并没有提到这个术语，但是在内核的确是用到了这个概念，比如__va和__pa这两个宏定义。看似神秘的 virtual address 究其本质就是程序里面使用的地址比如一个指针值，指针的本质就是 EIP 寄存器里的值，说直白点，virtual address 就是 EIP 寄存器的值。你会发现我们上面说过，logical address 由 selector 和 offset 两部分组成，offset 也是 EIP 寄存器的值，所以结论为：logical address 的 offset 正是 virtual address，它俩是一个东西。

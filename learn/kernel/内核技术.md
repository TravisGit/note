

## 内核旁路（kernel bypass）
参考链接：[如何实现内核旁路（Kernel bypass）？](http://blog.jobbole.com/94976/)

Linux接受网络请求时，要经过如下过程：
* 网卡接收到数据，触发中断，内核驱动将数据从网络接收到内核空间
* 将内核空间的数据拷贝到用户空间（拷贝操作往往代价较大），通知应用

内核处理数据并传递到用户空间的代价是很大的，为了获得更高性能，需要绕过内核。kernel bypass就是指完全绕过内核。

原本内核的存在是为了屏蔽硬件,让用户程序必须通过系统调用才能进入内核空间，使用硬件功能。这么做的好处是：
* 安全性：用户空间不能直接操控或者完全接管硬件。
* 易用性：内核对硬件进行了高度抽象，封装了实现细节，用户程序通过系统调用使用功能即可，更加统一。

那么要绕过内核，也就是说应用程序要直接操作硬件，实现起来无非是用户空间驱动 or 用户空间IO

无论哪种方式，kernel bypassh后，应用程序要么调用专用API进行IO，要么通过LD_PRELOAD覆盖系统调用，最终目的是在用户空间访问网卡。

目前的实现技术包括：

* Snabbswitch & DPDK：用户空间实现硬件驱动
* Netmap：由几个内核模块实现，为了和网络硬件集成在一起，需要给内核网络驱动打补丁
* Solarflare：LD_PRELOAD插桩方式覆盖网络系统调用，实际使用的是EF_VI专用库，但其仅能用于Solarflare网卡
* 分叉驱动 & 虚拟化技术

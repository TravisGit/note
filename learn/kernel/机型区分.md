

## 问题
* 多个IC——平台本身已经提取公共部分
* 多个供应商——即便同IC，可能固件不同、模组有区别
* 多个项目——即便同IC，同供应商，也可能硬件区别，导致配置区别；或者不同供应商

## 原始代码

```c
#include <mach/mt_pm_ldo.h>
#include <mach/mt_gpio.h>

static void lcm_get_params(LCM_PARAMS *params)
{
    ...

#ifdef CONFIG_TPLINK_PRODUCT_TP904
	params->dsi.PLL_CLOCK = 217;	/* this value must be in MTK suggested table, for MT6750 */
#else
	params->dsi.PLL_CLOCK = 230;
#endif

    ...
}


int func_1(){}

int func_2(){}

int func_n(){}


int get_lcd_id_by_aux(void)
{
    int ret = TIANMA_VOL, data[4], ret_value = 0;
    int Channel = AUX_IN2_NTC;
    static int valid_id = -1;

#ifdef CONFIG_TPLINK_PRODUCT_TP904
    int pcb_version_voltage = 0;
#endif


   ....
   
#ifdef CONFIG_TPLINK_PRODUCT_TP904
    if (ret > VOL_THRESHOLD_MIN1 && ret < VOL_THRESHOLD_MAX1) {
        ret = TIANMA_VOL;
    } else if (ret > VOL_THRESHOLD_MIN2 && ret < VOL_THRESHOLD_MAX2) {
        pcb_version_voltage = get_pcb_version_voltage();
        if (pcb_version_voltage < TP904_DVT1_VOLTAGE_MIN || pcb_version_voltage > TP904_DVT1_VOLTAGE_MAX) {
            ret = DJN_VOL;
        } else {
            ret = UNKNOWN_VOL;
        }
    } else {
        ret = UNKNOWN_VOL;
    }
#else
    if (ret > VOL_THRESHOLD_MIN1 && ret < VOL_THRESHOLD_MAX1) {
        ret = TIANMA_VOL;
    } else if (ret > VOL_THRESHOLD_MIN2 && ret < VOL_THRESHOLD_MAX2) {
        ret = TRUELY_VOL;
    } else {
        ret = UNKNOWN_VOL;
    }
#endif
    return ret;
}
EXPORT_SYMBOL_GPL(get_lcd_id_by_aux);
```


## 完全两份，如下代码重复：

```
int func_1(){}

int func_2(){}

int func_n(){}

```

## 多个头文件控制
* 902.h 903.h 904.h
* xxxxx.c

```c
#include <mach/mt_pm_ldo.h>
#include <mach/mt_gpio.h>

#ifdef CONFIG_TPLINK_PRODUCT_TP904
#include "904.h"
#else
#include "default.h"
#endif

static void lcm_get_params(LCM_PARAMS *params)
{
    ...

#ifdef CONFIG_TPLINK_PRODUCT_TP904
	params->dsi.PLL_CLOCK = pll_clock;	/* this value must be in MTK suggested table, for MT6750 */
#else
	params->dsi.PLL_CLOCK = pll_clock;
#endif

    ...
}


int func_1(){}

int func_2(){}

int func_n(){}


int get_lcd_id_by_aux(void)
{
    int ret = TIANMA_VOL, data[4], ret_value = 0;
    int Channel = AUX_IN2_NTC;
    static int valid_id = -1;


   ....
   
    if (ret > VOL_THRESHOLD_MIN1 && ret < VOL_THRESHOLD_MAX1) {
        ret = TIANMA_VOL;
    } else if (ret > VOL_THRESHOLD_MIN2 && ret < VOL_THRESHOLD_MAX2) {
        pcb_version_voltage = get_pcb_version_voltage();
        if (pcb_version_voltage < TP904_DVT1_VOLTAGE_MIN || pcb_version_voltage > TP904_DVT1_VOLTAGE_MAX) {
            ret = DJN_VOL;
        } else {
            ret = UNKNOWN_VOL;
        }
    } else {
        ret = UNKNOWN_VOL;
    }
    return ret;
}
EXPORT_SYMBOL_GPL(get_lcd_id_by_aux);
```

* 针对get_lcd_id_by_aux，需要精心设计，而对于DVT1之前是1供，DVT2之后是二供这种逻辑，则完全没法实现


## 目录结构

* 当前

```
.
├── ft8607_720p_dsi_vdo_tps65132_tianma
├── inc
├── lcm_common.c
├── mt65xx_lcm_list.c
└── mt65xx_lcm_list.h

```



* 延续平台风格
```
.
├── ft8607_720p_dsi_vdo_tps65132_tianma
├── ft8607_720p_dsi_vdo_tps65132_truly
├── inc
├── lcm_common.c
├── mt65xx_lcm_list.c
├── mt65xx_lcm_list.h
└── tplink
    ├── 902.c
    ├── 903.c
    ├── 904.c
    ├── 902.h
    ├── 903.h
    └── 904.h

```

* 尽可能减少重复代码
```
.
├── ft8607
│   ├── ft8607_common.c
│   ├── ft8607_common.h
│   ├── ft8607_tianma.c
│   └── ft8607_truly.c
├── inc
├── lcm_common.c
├── mt65xx_lcm_list.c
├── mt65xx_lcm_list.h
└── tplink
    ├── 902.c
    ├── 903.c
    ├── 904.c
    ├── 902.h
    ├── 903.h
    └── 904.h

```
如果不同平台的tps65132不同？上电接口统一实现在tplink目录,函数指针赋值
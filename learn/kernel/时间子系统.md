

想要说明的点：

功能有哪些

硬件实体有哪些

软件抽象有哪些

为什么要这样设计

软硬件的关联、驱动

低精度、高精度定时器，实现的算法






## 概述
Linux的时间子系统，从功能上讲，其实就两个：计时和定时。

结合应用场景来说：

获取时间：获取系统时间。如计算程序运行时间、记录日志（需包含时间标签）等场景下需要用到
定时功能：睡眠或定时功能。如硬件时序设定、timer定时唤醒进程、系统调度等都是基于定时器功能


内核空间获取时间的接口：[源码](http://androidxref.com/kernel_3.18/xref/include/linux/timekeeping.h)

##
硬件上主要有两种：

* counter：一个单调、递增的硬件计数器，只能计数不能发出任何中断

* timer：一个可编程的定时器，当计数器达到指定值时，可以发出中断

硬件上可以有多个不同精度和作用的counter&timer，linux kernel抽象出了用来描述它们的clock source和clock event模块，这两个模块与具体的硬件无关。


clock_event_device：对应于硬件timer，硬件上有多少timer，就可以注册多少clock_event。在timeline上的指定的点，产生clock event事件，

tick device：基于clock event设备，


drivers
drivers/clocksource：
arm_arch_timer.c
arm_global_timer.c

##完整驱动demo

以[arm_global_timer](http://androidxref.com/kernel_3.18/xref/drivers/clocksource/arm_arch_timer.c)为例


### 驱动程序的加载

```c
static void __init global_timer_of_register(struct device_node *np)
{
	struct clk *gt_clk;
	int err = 0;

	//从设备树获取硬件配置信息
	gt_ppi = irq_of_parse_and_map(np, 0);
	if (!gt_ppi) {
		pr_warn("global-timer: unable to parse irq\n");
		return;
	}
    ……

    //中断设置
    err = request_percpu_irq(gt_ppi, gt_clockevent_interrupt,
				 "gt", gt_evt);

	……
    //注册clocksource
	/* Immediately configure the timer on the boot CPU */
	gt_clocksource_init();

    //注册clockevent
	gt_clockevents_init(this_cpu_ptr(gt_evt));

	return;

out_irq:
	free_percpu_irq(gt_ppi, gt_evt);
out_free:
    ……
}

CLOCKSOURCE_OF_DECLARE(arm_gt, "arm,cortex-a9-global-timer",
			global_timer_of_register);

static irqreturn_t gt_clockevent_interrupt(int irq, void *dev_id)
{
	struct clock_event_device *evt = dev_id;

	……
	evt->event_handler(evt);

	return IRQ_HANDLED;
}

```
CLOCKSOURCE_OF_DECLARE语句产生的效果是：
* global_timer_of_register函数将在系统启动时执行；
* "arm,cortex-a9-global-timer"对应的设备树节点，将作为参数传入到global_timer_of_register

global_timer_of_register函数中做了什么？
* 从传入的设备树节点中获取硬件信息存入全局变量，如clock_event对应的中断号、clock频率等
* 中断的配置。clock_event_device是可以发出中断的，驱动中要配置相应的中断处理函数
* 将clocksource注册到时间子系统
* 将clock_event_device注册到时间子系统

补充：gt_clockevent_interrupt中断处理函数最终会调用clock_event_device->event_handler，event_handler是linux时间子系统的回调函数，这就保证Linux时间子系统能够在中断触发时完成特定的操作，如统计进程信息等。



### clocksource的注册

```c
static void __init gt_clocksource_init(void)
{
	writel(0, gt_base + GT_CONTROL);
    ……

    //将clocksource注册到时间子系统
	clocksource_register_hz(&gt_clocksource, gt_clk_rate);
}

static struct clocksource gt_clocksource = {
	.name	= "arm_global_timer",
	.rating	= 300,
	.read	= gt_clocksource_read,
	.mask	= CLOCKSOURCE_MASK(64),
	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
};

static cycle_t gt_clocksource_read(struct clocksource *cs)
{
	return gt_counter_read();
}

```

gt_clocksource_init是用于注册clocksource的函数，它做了两件事：
* 设定clocksource的工作状态（并不是所有的clocksource都有这一步）
* 将指定的gt_clocksource注册到时间子系统。clocksource_register_hz是一个通用接口，所有的clocksource都通过该接口注册，注册的结果就是该clocksource将被加入到内核的clocksource链表中，供内核选择使用。

clocksource如何与硬件的counter对应起来呢？在上述的代码段中，gt_clocksource的定义中填充了clocksource的硬件特性，同时也实现了clocksource的功能函数read，这就完成了对应。

### clock_event_device的注册

```c
static int gt_clockevents_init(struct clock_event_device *clk)
{
	int cpu = smp_processor_id();

	clk->name = "arm_global_timer";
	clk->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT |
		CLOCK_EVT_FEAT_PERCPU;
	clk->set_mode = gt_clockevent_set_mode;
	clk->set_next_event = gt_clockevent_set_next_event;
	clk->cpumask = cpumask_of(cpu);
	clk->rating = 300;
	clk->irq = gt_ppi;
	clockevents_config_and_register(clk, gt_clk_rate,
					1, 0xffffffff);
	enable_percpu_irq(clk->irq, IRQ_TYPE_NONE);
	return 0;
}

static void gt_clockevent_set_mode(enum clock_event_mode mode,
				   struct clock_event_device *clk)
{
	……
}

static int gt_clockevent_set_next_event(unsigned long evt,
					struct clock_event_device *unused)
{
	……
}

```

gt_clockevents_init用于注册clockevent，它也做了2件事：
* 根据从设备数读取到的硬件信息，填充clock_event_device结构
* 将clock_event_device注册到时间子系统。clockevents_config_and_register是一个通用接口，所有的clock_event_device都通过该接口注册。注册的结果就是将该clock_event_device加入到内核的clock_event列表中，供内核选择使用。

同样的，在驱动中要实现clock_event的各个功能接口函数，从而通过接口函数可以访问到底层硬件的功能。

### 总结
在clock驱动中，针对特定的硬件实体counter和timer，实现其软件抽象clocksource和clock_event_device，并将二者加入到全局的链表中，时间子系统基于此向上层提供更丰富的时间服务功能。
clocksource和clock_event_device从驱动层面来讲，没有任何联系。二者有各自的硬件特性参数，各自的功能函数，各自的注册函数。将clocksource和clock_event_device的驱动分成两份来实现，我认为也是没有问题的。至于为何内核中的驱动都是同时实现了clocksource和clock_event_device，可能是同一个硬件平台的clocksource和clock_event_device是一一对应的，或者说硬件上counter和timer可能是一体的。



深度讲解：[传送门](http://www.wowotech.net/timer_subsystem/armgeneraltimer.html)


关键数据结构

[timekeeper](http://androidxref.com/kernel_3.18/xref/include/linux/timekeeper_internal.h#77)

[clock_event_device](http://androidxref.com/kernel_3.18/xref/include/linux/clockchips.h#96)

深度讲解：[传送门](http://www.wowotech.net/timer_subsystem/clock-event.html)

[clocksource](http://androidxref.com/kernel_3.18/xref/include/linux/clocksource.h#167)

深度讲解：[传送门](http://www.wowotech.net/timer_subsystem/clocksource.html)


系统中可以有多个clock_source：
* timekeeper会从中选取一个最合适的来使用
* 当有更合适的clock_source注册，timekeeper可以更换clock_source
* timekeeper中所有类型的时间（real time，monotonic，boot time 等）都将基于选定clock_source计时

系统中可以有多个clock_event:


* 

tick_device有两种工作模式：

* periodic tick：传统的周期性tick
* oneshot tick：单次触发，在NO_HZ中使用

## timer的种类

低精度是什么意思？是粒度低还是精确度低？
* 时间的粒度低：低精度timer一般只能提供ms级精度，hrt_timer则可以提供ns级
* 时间的精度低：低精度timer不准，通常返回的时候已经超时了

###低精度timer

###高精度timer

## 功能
### 获取时间

### 调度


### 其他

* [NO_HZ](http://androidxref.com/kernel_3.18/xref/Documentation/timers/NO_HZ.txt): Reducing Scheduling-Clock Ticks，减少功耗和系统[抖动](https://en.wikipedia.org/wiki/Jitter)。比如在cpu idle时不触发scheduling-clock interrupts，避免不断唤醒系统从而导致功耗过大。
* Debug: 使用[/proc/timer_stats](http://androidxref.com/kernel_3.18/xref/Documentation/timers/timer_stats.txt)进行调试，不过要提前打开宏CONFIG_TIMER_STATS 
* tick broadcast framework：per cpud的local timer硬件无法正常运作的时候，需要一个独立于各个CPU的timer硬件来作为broadcast clock event device，将clock event广播到所有cpu core


## 用户空间接口
从应用程序的角度看，内核需要提供的和时间相关的服务有三种：
* 和系统时间相关的服务。例如，在向数据库写入一条记录的时候，需要记录操作时间（何年何月何日何时）。
* 让进程睡眠一段时间
* 和timer相关的服务。在一段指定的时间过去后，kernel要alert用户进程

### 时间的表示
人们习惯用于表示时间的方法是：年、月、日、时、分、秒、毫秒、星期等等，但是在内核中，为了软件逻辑和代码的方便性，它使用了一些不同的时间表示方法，并为这些表示方法定义了相应的变量和数据结构：
* jiffies：也叫ticks。系统每过1/HZ秒，jiffies值加1，是内核低精度定时器的计时单位
* timeval：由秒和微妙组成
```
struct timeval {  
    __kernel_time_t     tv_sec;     /* seconds */  
    __kernel_suseconds_t    tv_usec;    /* microseconds */  
}; 

```
* timespec：由秒和纳秒组成
```
struct timespec {  
    __kernel_time_t tv_sec;         /* seconds */  
    long        tv_nsec;        /* nanoseconds */  
}; 

```
* ktime：Linux通用时间架构以及高精度定时器都用ktime表示，64位系统直接由纳秒表示，32位系统中则拆分为秒和纳秒两部分
```
union ktime {  
    s64 tv64;  
#if BITS_PER_LONG != 64 && !defined(CONFIG_KTIME_SCALAR)  
    struct {  
# ifdef __BIG_ENDIAN  
    s32 sec, nsec;  
# else  
    s32 nsec, sec;  
# endif  
    } tv;  
#endif  
};   

```
内核提供了辅助函数用来在上述数据结构中转换。

### 计时功能
更多细节：[传送门](http://www.wowotech.net/timer_subsystem/timer_subsystem_userspace.html)

Linux系统有两个时钟：
* Real Time Clock：也叫RTC或者CMOS时钟，硬件时钟。当操作系统关机时，用它来记录时间，但对于运行时的系统是不用这个时间的。
* System Clock：也叫内核时钟或者软件时钟。其实现也是基于具体的时钟源（clock source），内核时钟在系统关机的情况下是不存在的。

当系统启动时，内核时钟会读取RTC时间来进行时间同步（有些情况下也可以通过ntp服务同步），最终linux的内核时间是记录从1970年1月1日距离现在的秒数


类别 | 描述 | 接口
---------|----------|---------
秒级别时间函数 | 返回或设定当前时间点<br>到Linux epoch的秒数 | #include <time.h><br>time_t time(time_t *t);<br>int stime(time_t *t);
微秒级别时间函数 | 同上，精度为微秒级别 | #include <sys/time.h><br>int gettimeofday(struct timeval *tv, struct timezone *tz);<br>int settimeofday(const struct timeval *tv, const struct timezone *tz);
纳秒级别时间函数 | 同上，精度为纳秒级别<br>可通过id获取不同系统时钟服务 | #include <time.h><br>int clock_getres(clockid_t clk_id, struct timespec *res);<br>int clock_gettime(clockid_t clk_id, struct timespec *tp);<br>int clock_settime(clockid_t clk_id, const struct timespec *tp);
系统时钟调整 | 根据delta参数缓慢修正系统时钟 | int adjtime(const struct timeval *delta, struct timeval *olddelta);<br>#include <sys/timex.h><br>int adjtimex(struct timex *buf);

Linux epoch： UNIX及Linux的时间系统是由「新纪元时间」Epoch开始计算起，单位为秒，Epoch则是指定为1970年一月一日凌晨零点零分零秒，格林威治时间。

### 睡眠和定时功能

与sleep相关的服务

类别 | 描述 | 接口
---------|----------|---------
 秒级别sleep | 当前进程睡眠一段时间后继续执行 | #include <unistd.h><br>unsigned int sleep(unsigned int seconds);
 微秒级别sleep | 同上 | #include <unistd.h><br>int usleep(useconds_t usec);
 纳秒级别sleep | 同上 | #include <time.h><br>int nanosleep(const struct timespec *req, struct timespec *rem);
 更高级sleep | 同上 | #include <time.h><br>int clock_nanosleep(clockid_t clock_id, int flags, <br>const struct timespec *request, <br>         struct timespec *remain);<br>

与timer相关的服务

类别 | 描述 | 接口
---------|----------|---------
 alarm | 在指定秒数过后，向进程发送SIGALRM信号。<br>调用该接口需要设定signal handler | #include <unistd.h><br>unsigned int alarm(unsigned int seconds);
 Interval timer | 精度为us，支持3中timer | #include <sys/time.h><br>int getitimer(int which, struct itimerval *curr_value); <br>int setitimer(int which, const struct itimerval *new_value, <br>              struct itimerval *old_value);
 POSIX timer | 更加高级、灵活 | #include <signal.h><br>#include <time.h><br>int timer_create(clockid_t clockid, struct sigevent *sevp,   timer_t *timerid);<br>……


## 参考资料
### Kernel Documention
内核的任何机制，在[内核文档](http://androidxref.com/kernel_3.18/xref/Documentation/timers/)中的描述一定是最清晰最全面的，timer同样是如此。

每一个模块会有一个目录，对于时间子系统timer，其目录文件00-INDEX:
```
00-INDEX
	- this file
highres.txt
	- High resolution timers and dynamic ticks design notes
hpet.txt
	- High Precision Event Timer Driver for Linux
hpet_example.c
	- sample hpet timer test program
hrtimers.txt
	- subsystem for high-resolution kernel timers
Makefile
	- Build and link hpet_example
NO_HZ.txt
	- Summary of the different methods for the scheduler clock-interrupts management.
timekeeping.txt
	- Clock sources, clock events, sched_clock() and delay timer notes
timers-howto.txt
	- how to insert delays in the kernel the right (tm) way.
timer_stats.txt
	- timer usage statistics

```
比如timers-howto.txt描述了如何在内核中使用延迟，根据是否在原子上下文，需要选择循环等待和睡眠定时器两种方式：
```
ATOMIC CONTEXT:
	You must use the *delay family of functions. These
	functions use the jiffie estimation of clock speed
	and will busy wait for enough loop cycles to achieve
	the desired delay:

	ndelay(unsigned long nsecs)
	udelay(unsigned long usecs)
	mdelay(unsigned long msecs)

NON-ATOMIC CONTEXT:
	You should use the *sleep[_range] family of functions.
	There are a few more options here, while any of them may
	work correctly, using the "right" sleep function will
	help the scheduler, power management, and just make your
	driver better :)

	-- Backed by busy-wait loop:
		udelay(unsigned long usecs)
	-- Backed by hrtimers:
		usleep_range(unsigned long min, unsigned long max)
	-- Backed by jiffies / legacy_timers
		msleep(unsigned long msecs)
		msleep_interruptible(unsigned long msecs)

```
### 博客
如下是时间子系统的系列博文，从wowo和CSDN转载，写的比较详细：

* [Linux时间子系统系列](http://www.wowotech.net/timer_subsystem/time_subsystem_index.html)

or

* [Linux时间子系统之一：clock source（时钟源）](http://blog.csdn.net/droidphone/article/details/7975694)
* [Linux时间子系统之二：表示时间的单位和结构](http://blog.csdn.net/droidphone/article/details/7979295)
* [Linux时间子系统之三：时间的维护者：timekeeper](http://blog.csdn.net/droidphone/article/details/7989566)
* [Linux时间子系统之四：定时器的引擎：clock_event_device](http://blog.csdn.net/droidphone/article/details/8017604)
* [Linux时间子系统之五：低分辨率定时器的原理和实现](http://blog.csdn.net/droidphone/article/details/8051405)
* [Linux时间子系统之六：高精度定时器（HRTIMER）的原理和实现](http://blog.csdn.net/droidphone/article/details/8074892)
* [Linux时间子系统之七：定时器的应用--msleep()，hrtimer_nanosleep()](http://blog.csdn.net/droidphone/article/details/8104433)
* [Linux时间子系统之八：动态时钟框架（CONFIG_NO_HZ、tickless）](http://blog.csdn.net/droidphone/article/details/8112948)

